/*
 * Copyright 2019 EPAM Systems, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.epam.inject.viewmodel.processor

import com.google.testing.compile.CompilationSubject
import com.google.testing.compile.Compiler
import com.google.testing.compile.JavaFileObjects
import org.junit.Before
import org.junit.Test
import javax.tools.JavaFileObject

class ModuleTest {

    private lateinit var processor: AssistedViewModelProcessor

    @Before
    fun setUp() {
        processor = AssistedViewModelProcessor()
    }

    private val viewModelClass = JavaFileObjects
            .forSourceString(
                    "test.ViewModelClass",
                    """
                package test;

            import com.epam.inject.viewmodel.AssistedViewModel;
            import androidx.lifecycle.ViewModel;

            public class ViewModelClass extends ViewModel {

                @AssistedViewModel
                public ViewModelClass() {
                }

            }
            """
            )

    @Test
    fun `module with one viewmodel`() {

        val expectedModule = JavaFileObjects.forSourceString(
            "com.epam.inject.viewmodel.ViewModelInjectModule",
                """
            package com.epam.inject.viewmodel;

            import androidx.lifecycle.ViewModel;
            import dagger.Module;
            import dagger.Provides;
            import dagger.multibindings.IntoMap;
            import test.ViewModelClass;

            /**
             * Generated by dagger-2-vm-inject
             * 17-May-2019 13:25
             */
            @Module(
                includes = GeneratedViewModelFactoryModule.class
            )
            public class ViewModelInjectModule {
            @Provides
            @IntoMap
            @ViewModelKey(test.ViewModelClass.class)
            public static ViewModel provide_test_ViewModelClass() {
              return new ViewModelClass();
            }
            }
        """.trimIndent()
        )

        compileAndAssertSuccess(expectedModule, viewModelClass)
    }

    @Test
    fun `module with many viewmodels`() {

        val secondViewModelClass = JavaFileObjects
                .forSourceString(
                        "test.SecondViewModelClass",
                        """
                package test;

            import com.epam.inject.viewmodel.AssistedViewModel;
            import androidx.lifecycle.ViewModel;

            public class SecondViewModelClass extends ViewModel {

                @AssistedViewModel
                public SecondViewModelClass() {
                }

            }
            """
                )

        val expectedModule = JavaFileObjects.forSourceString(
            "com.epam.inject.viewmodel.ViewModelInjectModule",
                """
            package com.epam.inject.viewmodel;

            import androidx.lifecycle.ViewModel;
            import dagger.Module;
            import dagger.Provides;
            import dagger.multibindings.IntoMap;
            import test.SecondViewModelClass;
            import test.ViewModelClass;

            /**
             * Generated by dagger-2-vm-inject
             * 17-May-2019 13:25
             */
            @Module(
                includes = GeneratedViewModelFactoryModule.class
            )
            public class ViewModelInjectModule {
            @Provides
            @IntoMap
            @ViewModelKey(test.ViewModelClass.class)
            public static ViewModel provide_test_ViewModelClass() {
              return new ViewModelClass();
            }

            @Provides
            @IntoMap
            @ViewModelKey(test.SecondViewModelClass.class)
            public static ViewModel provide_test_SecondViewModelClass() {
              return new SecondViewModelClass();
            }
            }
        """.trimIndent()
        )

        compileAndAssertSuccess(expectedModule, viewModelClass, secondViewModelClass)
    }

    @Test
    fun `viewmodel with one dependency`() {

        val dependencyViewModel = JavaFileObjects
                .forSourceString(
                        "test.DependencyViewModelClass",
                        """
                package test;

            import com.epam.inject.viewmodel.AssistedViewModel;
            import androidx.lifecycle.ViewModel;
            import java.lang.String;

            public class DependencyViewModelClass extends ViewModel {
                private final String dependency;

                @AssistedViewModel
                public DependencyViewModelClass(String dependency){
                    this.dependency = dependency;
                }

            }
            """
                )

        val expectedModule = JavaFileObjects.forSourceString(
            "com.epam.inject.viewmodel.ViewModelInjectModule",
                """
            package com.epam.inject.viewmodel;

            import androidx.lifecycle.ViewModel;
            import dagger.Module;
            import dagger.Provides;
            import dagger.multibindings.IntoMap;
            import java.lang.String;
            import test.DependencyViewModelClass;

            /**
             * Generated by dagger-2-vm-inject
             * 17-May-2019 13:25
             */
            @Module(
                includes = GeneratedViewModelFactoryModule.class
            )
            public class ViewModelInjectModule {
            @Provides
            @IntoMap
            @ViewModelKey(test.DependencyViewModelClass.class)
            public static ViewModel provide_test_DependencyViewModelClass(String dependency) {
              return new DependencyViewModelClass(dependency);
            }
            }
        """.trimIndent()
        )

        compileAndAssertSuccess(expectedModule, dependencyViewModel)
    }

    @Test
    fun `viewmodel with many dependencies`() {
        val dependenciesViewModel = JavaFileObjects
                .forSourceString(
                        "test.DependenciesViewModelClass",
                        """
                package test;

            import com.epam.inject.viewmodel.AssistedViewModel;
            import androidx.lifecycle.ViewModel;
            import java.lang.Object;
            import java.lang.String;

            public class DependenciesViewModelClass extends ViewModel {
                private final String dependencyStr;
                private final Object dependencyObj;

                @AssistedViewModel
                public DependenciesViewModelClass(String dependencyStr, Object dependencyObj){
                    this.dependencyStr = dependencyStr;
                    this.dependencyObj = dependencyObj;
                }

            }
            """
                )

        val expectedModule = JavaFileObjects.forSourceString(
            "com.epam.inject.viewmodel.ViewModelInjectModule",
                """
            package com.epam.inject.viewmodel;

            import androidx.lifecycle.ViewModel;
            import dagger.Module;
            import dagger.Provides;
            import dagger.multibindings.IntoMap;
            import java.lang.Object;
            import java.lang.String;
            import test.DependenciesViewModelClass;

            /**
             * Generated by dagger-2-vm-inject
             * 17-May-2019 13:25
             */
            @Module(
                includes = GeneratedViewModelFactoryModule.class
            )
            public class ViewModelInjectModule {
            @Provides
            @IntoMap
            @ViewModelKey(test.DependenciesViewModelClass.class)
            public static ViewModel provide_test_DependenciesViewModelClass(String dependencyStr, Object dependencyObj) {
              return new DependenciesViewModelClass(dependencyStr, dependencyObj);
            }
            }
        """.trimIndent()
        )

        compileAndAssertSuccess(expectedModule, dependenciesViewModel)
    }

    @Test
    fun `viewmodel with several annotated constructors`() {
        val dependenciesViewModel = JavaFileObjects
                .forSourceString(
                        "test.DependenciesViewModelClass",
                        """
                package test;

            import com.epam.inject.viewmodel.AssistedViewModel;
            import androidx.lifecycle.ViewModel;
            import java.lang.Object;
            import java.lang.String;

            public class DependenciesViewModelClass extends ViewModel {
                private final String dependencyStr;
                private final Object dependencyObj;

                @AssistedViewModel
                public DependenciesViewModelClass(String dependencyStr){
                    this.dependencyStr = dependencyStr;
                }

                @AssistedViewModel
                public DependenciesViewModelClass(Object dependencyObj){
                    this.dependencyObj = dependencyObj;
                }

            }
            """
                )

        val compilation = Compiler.javac().withProcessors(processor).compile(dependenciesViewModel)
        CompilationSubject.assertThat(compilation)
                .hadErrorContainingMatch("Class .+ has more then one constructor marked " +
                        "with AssistedViewModel annotation")
    }

    @Test
    fun `viewmodel with one annotated constructor`() {
        val dependenciesViewModel = JavaFileObjects
                .forSourceString(
                        "test.DependenciesViewModelClass",
                        """
                package test;

            import com.epam.inject.viewmodel.AssistedViewModel;
            import androidx.lifecycle.ViewModel;
            import java.lang.Object;
            import java.lang.String;

            public class DependenciesViewModelClass extends ViewModel {
                private String dependencyStr = null;
                private Object dependencyObj = null;

                public DependenciesViewModelClass(String dependencyStr){
                    this.dependencyStr = dependencyStr;
                }

                @AssistedViewModel
                public DependenciesViewModelClass(Object dependencyObj){
                    this.dependencyObj = dependencyObj;
                }

            }
            """
                )

        val expectedModule = JavaFileObjects.forSourceString(
            "com.epam.inject.viewmodel.ViewModelInjectModule",
                """
            package com.epam.inject.viewmodel;

            import androidx.lifecycle.ViewModel;
            import dagger.Module;
            import dagger.Provides;
            import dagger.multibindings.IntoMap;
            import java.lang.Object;
            import test.DependenciesViewModelClass;

            /**
             * Generated by dagger-2-vm-inject
             * 20-May-2019 9:00
             */
            @Module(
                includes = GeneratedViewModelFactoryModule.class
            )
            public class ViewModelInjectModule {
            @Provides
            @IntoMap
            @ViewModelKey(test.DependenciesViewModelClass.class)
            public static ViewModel provide_test_DependenciesViewModelClass(Object dependencyObj) {
              return new DependenciesViewModelClass(dependencyObj);
            }
            }
        """.trimIndent()
        )

        compileAndAssertSuccess(expectedModule, dependenciesViewModel)
    }

    @Test
    fun `module for ViewModels with same name but different package`() {

        val firstViewModelClass = JavaFileObjects
            .forSourceString(
                "test.TestViewModelClass",
                """
                package test;

            import com.epam.inject.viewmodel.AssistedViewModel;
            import androidx.lifecycle.ViewModel;

            public class TestViewModelClass extends ViewModel {

                @AssistedViewModel
                public TestViewModelClass() {
                }

            }
            """
            )

        val secondViewModelClass = JavaFileObjects
            .forSourceString(
                "prod.TestViewModelClass",
                """
                package prod;

            import com.epam.inject.viewmodel.AssistedViewModel;
            import androidx.lifecycle.ViewModel;

            public class TestViewModelClass extends ViewModel {

                @AssistedViewModel
                public TestViewModelClass() {
                }

            }
            """
            )

        val expectedModule = JavaFileObjects.forSourceString(
            "com.epam.inject.viewmodel.ViewModelInjectModule",
            """
            package com.epam.inject.viewmodel;

            import androidx.lifecycle.ViewModel;
            import dagger.Module;
            import dagger.Provides;
            import dagger.multibindings.IntoMap;
            import test.TestViewModelClass;

            /**
             * Generated by dagger-2-vm-inject
             * 28-May-2019 9:05
             */
            @Module(
                includes = GeneratedViewModelFactoryModule.class
            )
            public class ViewModelInjectModule {
            @Provides
            @IntoMap
            @ViewModelKey(test.TestViewModelClass.class)
            public static ViewModel provide_test_TestViewModelClass() {
              return new TestViewModelClass();
            }

            @Provides
            @IntoMap
            @ViewModelKey(prod.TestViewModelClass.class)
            public static ViewModel provide_prod_TestViewModelClass() {
              return new prod.TestViewModelClass();
            }
            }
        """.trimIndent()
        )

        compileAndAssertSuccess(expectedModule, firstViewModelClass, secondViewModelClass)
    }

    private fun compileAndAssertSuccess(expectedModule: JavaFileObject, vararg files: JavaFileObject) {
        val compilation = Compiler.javac().withProcessors(processor).compile(*files)

        CompilationSubject.assertThat(compilation)
                .succeeded()
        CompilationSubject.assertThat(compilation)
            .generatedSourceFile("com.epam.inject.viewmodel.ViewModelInjectModule")
                .hasSourceEquivalentTo(expectedModule)
    }
}